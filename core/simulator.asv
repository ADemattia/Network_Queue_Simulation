classdef simulator < handle
    %SIMULATOR Summary of this class goes here
    %   Detailed explanation goes here
    
    properties
        externalClock
        horizon
        
        queueNodes % array entità: code, generatori, server
        queueArray % array code 
        
        queueGraph % Matrice di adiacenza per descrizione network di code 
        eventsList
         
        endQueue % coda finale accumulo a fine sistema 

        displayFlag % flag per vedere la dinamica 
    end
    
    methods
        function obj = simulator(horizon,queueNodes,queueGraph, displayFlag)
            % istanziazioni di default
            obj.externalClock = 0; 
            numEntities = length(queueNodes); 
            obj.eventsList = inf(numEntities,1);

            obj.horizon = horizon; 
            obj.queueNodes = queueNodes; 
            obj.queueArray = [obj.queueNodes{cellfun(@(x) isa(x, 'queue'), obj.queueNodes)}]; 
            obj.queueGraph = queueGraph;
            obj.displayFlag = displayFlag; 

            waitingFlag = false; 
            obj.endQueue = classicQueue(1, waitingFlag, inf); % coda classica a capacità infinita 
        end

        function networkSetUp(obj)

            networkLength = length(obj.queueNodes); 
            for i = 1: networkLength
                node = obj.queueNodes{i};

                if isa(node, 'generator')
                    % cerca coda a cui è collegato da matrice adiancenza 
                    queueId = find(obj.queueGraph(i, :) == 1); 
                    node.queueAssignment(obj.queueNodes{queueId}, networkLength); 

                elseif isa(node, 'queue')
                    destinationServerId = find(obj.queueGraph(i, :) == 1);
                    node.destinationServerAssignment(obj.queueNodes{destinationServerId}); 

                    % assegnazione server e generatori precedenti queue 
                    previousEntitiesId = find(obj.queueGraph(:, i) == 1);
                    previousGeneratorsId = []; 
                    previousServersId = [];

                    for j = 1:length(previousEntitiesId)
                        entityId = previousEntitiesId(j);
                        entity = obj.queueNodes{entityId};
                        
                        if isa(entity, 'generator')
                            previousGeneratorsId(end+1) = entityId;  
                        elseif isa(entity, 'server')
                            previousServersId(end+1) = entityId;    
                        end
                    end
                    
                    previousGenerators = [obj.queueNodes{previousGeneratorsId}];
                    previousServers = [obj.queueNodes{previousServersId}];
                    
                    node.previousGeneratorsAssignment(previousGenerators);
                    node.previousServersAssignment(previousServers);

                else % isa(node, 'server')
                    previousQueueId = find(obj.queueGraph(:, i) == 1);
                    previousQueues = [obj.queueNodes{previousQueueId}];  % array di oggetti coda
                    node.previousQueuesAssignment(previousQueues); 
                    
                    % server terminale
                    if i == networkLength % server finale
                        node.destinationQueueAssignment(obj.endQueue) % i customer finiscono nella coda di accumulo finale
                    else
                        destinationQueueId = find(obj.queueGraph(i, :) == 1);
                        node.destinationQueueAssignment(obj.queueNodes{destinationQueueId});
                    end 
                end
            end 
        end
        

        function excuteSimulation(obj)
            for i = 1: length(obj.queueNodes)
                node = obj.queueNodes{i};
                if isa(node, 'generator')
                    node.scheduleNextArrival();
                end
            end

            % setup primi eventi 
            for i = 1 : length(obj.queueNodes)
                node = obj.queueNodes{i};
                % code non influenzano contatore, sono solo contenitori
                % eventi sono dettati da generator e server 
                if isa(node, 'queue')
                    % non fare nulla 
                else % server e generator 
                     obj.eventsList(i) = node.clock; 
                end
            end 

            contatore = 0; 
            while obj.externalClock < obj.horizon
                [nextEvent, nextId] = min(obj.eventsList);
                eventNode = obj.queueNodes{nextId};

                if obj.displayFlag == true 

                    fprintf('\n--- Iterazione #%d ---\n', contatore);
                    fprintf('Clock attuale: %.4f\n', obj.externalClock);
                    fprintf('Lista eventi:\n');
                    
                    for idx = 1:length(obj.eventsList)
                        if isinf(obj.eventsList(idx))
                            fprintf('  Nodo %2d: INF\n', idx);
                        else
                            fprintf('  Nodo %2d: %.4f\n', idx, obj.eventsList(idx));
                        end
                    end

                    if isa(eventNode, 'generator')
                        nodeType = 'Generator';
                    elseif isa(eventNode, 'queue')
                        nodeType  = 'Queue';
                    elseif isa(eventNode, 'server')
                        nodeType  = 'Server';
                    end
                    
                    fprintf('Prossimo evento: Nodo %d (%s)\n', nextId, nodeType );
                    fprintf('\n');  
                    
                    contatore = contatore + 1;
                end

                % prossimo evento 
                obj.externalClock = nextEvent; 

                for k = 1:length(obj.queueArray) % aggiorniamo i clock di ogni coda 
                    queueToClock = obj.queueArray(k); % clock per coda servono a statistiche non per lista eventi
                    queueToClock.clockUpdate(obj.externalClock); % aggiorna anche lunghezza media 
                end

                if isa(eventNode, 'generator')
                    gen = eventNode; 

                    queue = gen.queueDestination; 
                    server = queue.destinationServer;

                    gen.customerExit(); % gestisce uscita da generatore e entrata coda 

                    if obj.displayFlag == true
                        obj.displaySystemState
                    end
   
                    [servicePossible, selectedCustomer] = server.checkAvailability(); % verifica se si può schedulare nuovo servizio 
             
                    while servicePossible == 1   % servizio possibile
                        server.scheduleNextEvents(selectedCustomer,obj.externalClock);

                        if obj.displayFlag == true
                            obj.displaySystemState
                        end
 
                        obj.eventsList(server.id) = server.clock; % aggiorna prossimo evento legato a server

                        % verifica se coda può accogliere nuovo customer 
                        updatedQueue = server.selectedQueue; % coda di provenienza del customer
                        obj.propagateExit(updatedQueue);
                        [servicePossible, selectedCustomer] = server.checkAvailability();
                    end

                    gen.scheduleNextArrival();
                    obj.eventsList(gen.id) = gen.clock; % aggiorna prossimo evento legato a server % aggiorna prossimo evento legato a generatore

                else % isa(eventNode,'server')
                    server = eventNode; 
                    server.addWaiting(obj.externalClock); % addWaiting deschedula l'evento precedente 

                    if obj.displayFlag == true
                        obj.displaySystemState
                    end

                    obj.eventsList(server.id) = server.clock; % aggiorna prossimo evento legato a server
    
                    if server.canExit() % verifica se si può rilasciare customer in coda
                        server.exitCustomer(obj.externalClock);
                        obj.eventsList(server.id) = server.clock;

                        if obj.displayFlag == true
                            obj.displaySystemState
                        end


                        while server.canExit() % verifica se si può svuotare ulteriormente la waiting list 
                            server.exitCustomer(obj.externalClock);
                            obj.eventsList(server.id) = server.clock;

                            if obj.displayFlag == true
                                obj.displaySystemState
                            end

                        end 


                        queue = server.destinationQueue; % coda successiva 

                        % verifica su schedulazione evento server successivo  
                        if ~isequal(queue, obj.endQueue) % se non è la coda finale
                            nextServer = queue.destinationServer; 
                           
                            [nextServicePossible, nextSelectedCustomer] = nextServer.checkAvailability(); % server successivo può prendere nuovo customer

                            if nextServicePossible == 1
                                nextServer.scheduleNextEvents(nextSelectedCustomer,obj.externalClock);

                                if obj.displayFlag == true
                                    obj.displaySystemState
                                end
                                
                                obj.eventsList(nextServer.id) = nextServer.clock; % aggiorna prossimo evento legato a server
                            end 
                        end 
                    end 

                    [servicePossible, selectedCustomer] = server.checkAvailability();  % verifica disponibilità

                    while servicePossible == true % servizio possibile
                        server.scheduleNextEvents(selectedCustomer,obj.externalClock);

                        if obj.displayFlag == true
                            obj.displaySystemState
                        end

                        obj.eventsList(server.id) = server.clock; % aggiorna prossimo evento legato a server
                        
                        % verifica se coda può accogliere nuovo customer 
                        updatedQueue = server.selectedQueue; % coda di provenienza del customer
                        obj.propagateExit(updatedQueue); % propagazione 

                        [servicePossible, selectedCustomer] = server.checkAvailability();  % verifica nuova disponibilità
                    end

                    obj.eventsList(server.id) = server.clock; 
                end
            end
        end 

        function propagateExit(obj, queue) % funzione ricorsiva
            previousServers = queue.previousServers; % vettore server precedenti la coda 

            if isempty(queue.previousServers)
                return;
            end

            for i = 1:length(previousServers) % nessuna priorità (solo ordine in grafo) 
                server = previousServers(i); 
                exitAllowed = server.canExit();
                if exitAllowed == true
                    server.exitCustomer(obj.externalClock); % inserito customer in coda
                    obj.eventsList(server.id) = server.clock;

                    % COMMENTO: se è possibile prendere in carico un nuovo
                    % customer, si aggiornano ricorsivamente le code
                    % precedenti 

                    [servicePossible, selectedCustomer] = server.checkAvailability(); 

                    while servicePossible == true % servizio possibile

                        server.scheduleNextEvents(selectedCustomer,obj.externalClock); % customer tolto da coda precedente 

                        if obj.displayFlag == true
                            obj.displaySystemState
                        end

                        obj.eventsList(server.id) = server.clock; % aggiorna prossimo evento legato a server 

                        updatedQueue = server.selectedQueue; % coda di provenienza del customer
                        obj.propagateExit(updatedQueue); % ricorsione chiamata quando serve

                        [servicePossible, selectedCustomer] = server.checkAvailability();
                    end
                end
            end
        end

        function displayCustomerTrajectories(obj)
            N = 10;
        
            q = obj.endQueue;
            totalCustomers = length(q.customerList);
            N = min(N, totalCustomers);
        
            % Scegli N clienti casuali
            idxCustomers = randperm(totalCustomers, N);
        
            fprintf('\n========= TRAIETTORIE CUSTOMER CASUALI =========\n\n');
        
            for c = 1:N
                customer = q.customerList(idxCustomers(c));
                fprintf('Customer %d (ID %d):\n', c, idxCustomers(c));
                fprintf('  %-20s %-10s %-10s\n', 'Nodo', 'Start Time', 'End Time'); % intestazione
        
                for j = 1:(length(customer.path)-1) 
                    nodeIndex = customer.path(j);
                    if nodeIndex <= length(obj.queueNodes) && nodeIndex > 0
                        node = obj.queueNodes{nodeIndex};
                        nodeLabel = sprintf('%s(%d)', class(node), node.id);
                    else
                        nodeLabel = sprintf('UnknownNode(%d)', nodeIndex);
                    end
                    st = customer.startTime(j);
                    et = customer.endTime(j);
        
                    fprintf('  %-20s %10.3f %10.3f\n', nodeLabel, st, et);
                end
                fprintf('-----------------------------\n');
            end
        end


        function statisticsArrayWaiting = waitingTimeStatistic(obj)
            % customers: array di customer con campi arrivalTime, startTime e endTime
            customerList     = obj.endQueue.customerList;
            numEntities      = length(obj.queueNodes); 
            waitingTimeTotal = zeros(numEntities,1);
            totalCount       = zeros(numEntities,1); 
            
            % calcolo tempi totali e conteggi
            for i = 1:length(customerList)
                customer = customerList(i); 
                for j = 1:numEntities
                    if ~isnan(customer.endTime(j))
                        totalCount(j) = totalCount(j) + 1;
                        waitingTimeTotal(j) = waitingTimeTotal(j) + ...
                            (customer.endTime(j) - customer.startTime(j));
                    end 
                end 
            end 
        
            % calcolo tempi medi (evitando divisione per zero)
            averageWaitingTime = NaN(numEntities,1);
            for j = 1:numEntities
                if totalCount(j) > 0
                    averageWaitingTime(j) = waitingTimeTotal(j) / totalCount(j);
                end
            end
        
            % stampa delle statistiche di waiting time
            fprintf('\n====== WAITING TIME STATISTICS ======\n');
            statisticsArrayWaiting = cell(numEntities,1);
            for j = 1:numEntities
                node = obj.queueNodes{j};
                stats = struct();
                
                % tipo di nodo
                if isa(node, 'generator')
                    stats.type = 'generator';
                elseif isa(node, 'queue')
                    stats.type = 'queue';
                elseif isa(node, 'server')
                    stats.type = 'server';
                else
                    stats.type = 'unknown';
                end
                
                stats.id      = node.id;
                stats.count   = totalCount(j);
                stats.avgWait = averageWaitingTime(j);
        
                switch stats.type
                    case 'generator'
                        nodeLabel = 'Generatore';
                    case 'queue'
                        nodeLabel = 'Coda';
                    case 'server'
                        nodeLabel = 'Server';
                end
        
                if isnan(stats.avgWait)
                    fprintf('%s ID %d (%s): nessun cliente servito\n', ...
                            nodeLabel, stats.id, stats.type);
                else
                    fprintf('%s ID %d (%s): clienti serviti = %d, tempo medio di attesa = %.2f\n', ...
                            nodeLabel, stats.id, stats.type, stats.count, stats.avgWait);
                end
        
                statisticsArrayWaiting{j} = stats;
            end
            fprintf('======================================\n\n');
        end


        
         function displaySystemState(obj)
            fprintf('\n========= SYSTEM STATE =========\n\n');
            
            % stato dei server
            fprintf('--- SERVER STATUS ---\n');
            for i = 1:length(obj.queueNodes)
                node = obj.queueNodes{i};
                if isa(node, 'server')
                    fprintf('Server ID: %d\n', node.id);
                    for j = 1:length(node.serverState)
                        fprintf('\tServitor %d: %s\n', j, string(node.serverState(j)));
                    end
                end
            end
            
            % stato delle code
            fprintf('\n--- QUEUE STATUS ---\n');
            for i = 1:length(obj.queueNodes)
                node = obj.queueNodes{i};
                if isa(node, 'queue')
                    fprintf('Queue ID: %d - Length: %d\n', node.id, node.lengthQueue);
                end
            end
        
            fprintf('\n===============================\n');
         end

         function statisticsArray = collectStatistics(obj)
            statisticsArray = cell(length(obj.queueNodes), 1);
        
            fprintf('\n========= STATISTICHE FINALI =========\n');
        
            for i = 1:length(obj.queueNodes)
                node = obj.queueNodes{i};
                stats = struct(); % statistiche salvate in struct 
        
                if isa(node, 'generator')
                    stats.type = 'generator';
                    stats.count = node.count;
                    stats.countPerType = node.countPerType;
                    
                    fprintf('Generatore ID %d: clienti generati = %d\n', node.id, node.count);
                    for t = 1:length(node.countPerType)
                        fprintf('   Tipo %d: %d clienti\n', t, node.countPerType(t));
                    end

        
                elseif isa(node, 'queue')
                    stats.type = 'queue';
                    stats.lostCustomer = node.lostCustomer;
                    stats.lengthQueue = node.lengthQueue;
                    stats.count = node.count;  % <-- conteggio totale clienti passati
                    stats.averageLength = node.averageLength; 
                    fprintf('Coda ID %d: clienti totali = %d, persi = %d, lunghezza finale = %d, lunghezza media = %.2f\n', ...
                            node.id, node.count, node.lostCustomer, node.lengthQueue, node.averageLength);
                        
                elseif isa(node, 'server')
                    stats.type = 'server';
                    stats.count = node.count;
                    stats.revenue = node.revenue;
                    fprintf('Server ID %d: clienti serviti = %d, revenue = %.2f\n', ...
                            node.id, node.count, node.revenue);
                    stats.timeInFree = node.timeInFree;
                    stats.timeInWorking = node.timeInWorking;
                    stats.timeInWaiting = node.timeInWaiting;
                    stats.timeInStuck = node.timeInStuck;
        
                    fprintf('Server ID %d: clienti serviti = %d, revenue = %.2f\n', ...
                            node.id, node.count, node.revenue);
                    % tempo occupazione per ogni server
                    numServer = length(node.timeInFree);
                    for j = 1:numServer
                        fprintf('   Subserver %d: Free=%.2f, Working=%.2f, Waiting=%.2f, Stuck=%.2f\n', j, ...
                            node.timeInFree(j), node.timeInWorking(j), node.timeInWaiting(j), node.timeInStuck(j));
                    end
        
                else
                    stats.type = 'unknown';
                end
        
                statisticsArray{i} = stats;
            end
        
            fprintf('======================================\n\n');
         end

         


         function clearSimulator(obj)

            for i = 1:length(obj.queueNodes)
                node = obj.queueNodes{i};
       
                if isa(node, 'server')
                    node.clearServer();
        
                elseif isa(node, 'generator')
                    node.clearGenerator();
        
                elseif isa(node, 'queue') 
                    node.clearQueue();
                end
            end
        
            % pulitura coda finale 
            if ~isempty(obj.endQueue) && ismethod(obj.endQueue, 'clearQueue')
                obj.endQueue.clearQueue();
            end
        
            % azzeramento clock e lista eventi 
            obj.externalClock = 0;
            obj.eventsList(:) = inf;
        
            fprintf('Tutte le statistiche sono state azzerate.\n');
         end


    end
end

